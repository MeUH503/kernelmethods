
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Drop-in Estimator classes &#8212; kernelmethods 0.2 documentation</title>
    <link rel="stylesheet" href="_static/pd.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Kernel Operations" href="operations.html" />
    <link rel="prev" title="Collections of kernel matrices" href="km_collections.html" />
    <script type="text/javascript" src="_static/pd.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

  </head><body>
    <div id="header">
        <h1>kernelmethods 0.2 documentation</h1>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
        <ul>
            <li class="nav-item nav-item-0"><a href="index.html">kernelmethods 0.2 documentation</a> &#187;
            </li>
        </ul>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
<div class="section" id="drop-in-estimator-classes">
<h1>Drop-in Estimator classes<a class="headerlink" href="#drop-in-estimator-classes" title="Permalink to this headline">¶</a></h1>
<p>Besides being able to use the aforementioned <code class="docutils literal notranslate"><span class="pre">KernelMatrix</span></code> in SVM or another kernel machine, this library makes life even easier by providing drop-in Estimator classes directly. It’s called <code class="docutils literal notranslate"><span class="pre">KernelMachine</span></code> and they can be dropped in place of <code class="docutils literal notranslate"><span class="pre">sklearn.svm.SVC</span></code> anywhere. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">kernelmethods</span> <span class="kn">import</span> <span class="n">KernelMachine</span>
<span class="n">km</span> <span class="o">=</span> <span class="n">KernelMachine</span><span class="p">(</span><span class="n">k_func</span><span class="o">=</span><span class="n">rbf</span><span class="p">)</span>
<span class="n">km</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">sample_data</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
<span class="n">predicted_y</span> <span class="o">=</span> <span class="n">km</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">sample_data</span><span class="p">)</span>
</pre></div>
</div>
<p>And if you’re not sure which kernel function is optimal for your dataset, you can employ <code class="docutils literal notranslate"><span class="pre">OptimalKernelSVR</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">kernelmethods</span> <span class="kn">import</span> <span class="n">OptimalKernelSVR</span>
<span class="n">opt_km</span> <span class="o">=</span> <span class="n">OptimalKernelSVR</span><span class="p">(</span><span class="n">k_bucket</span><span class="o">=</span><span class="s1">&#39;exhaustive&#39;</span><span class="p">)</span>
<span class="n">opt_km</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">sample_data</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
<span class="n">predicted_y</span> <span class="o">=</span> <span class="n">opt_km</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">sample_data</span><span class="p">)</span>
</pre></div>
</div>
<p>See below for the API.</p>
<p><strong>Stay tuned</strong> for more tutorials, examples and comprehensive docs.</p>
<div class="section" id="kernel-machine-api">
<h2>Kernel Machine (API)<a class="headerlink" href="#kernel-machine-api" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="kernelmethods.KernelMachine">
<em class="property">class </em><code class="sig-prename descclassname">kernelmethods.</code><code class="sig-name descname">KernelMachine</code><span class="sig-paren">(</span><em class="sig-param">k_func</em>, <em class="sig-param">learner_id='SVR'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/kernelmethods/algorithms.html#KernelMachine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kernelmethods.KernelMachine" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code></p>
<p>Generic class to return a drop-in sklearn estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k_func</strong> (<em>KernelFunction</em>) – The kernel function the kernel machine bases itself on</p></li>
<li><p><strong>learner_id</strong> (<em>str</em>) – Identifier for the estimator to be built based on the kernel function.
Options: <code class="docutils literal notranslate"><span class="pre">SVM</span></code> and <code class="docutils literal notranslate"><span class="pre">SVR</span></code>.
Default: <code class="docutils literal notranslate"><span class="pre">SVR</span></code></p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="kernelmethods.KernelMachine.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">y</em>, <em class="sig-param">sample_weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/kernelmethods/algorithms.html#KernelMachine.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kernelmethods.KernelMachine.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the chosen Estimator based on the user-defined kernel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Training vectors, where n_samples is the number of samples
and n_features is the number of features.
For kernel=”precomputed”, the expected shape of X is
(n_samples, n_samples).</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>,</em><em>)</em>) – Target values (class labels in classification, real numbers in
regression)</p></li>
<li><p><strong>sample_weight</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>,</em><em>)</em>) – Per-sample weights. Rescale C per sample. Higher weights
force the classifier to put more emphasis on these points.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If X and y are not C-ordered and contiguous arrays of np.float64 and
X is not a scipy.sparse.csr_matrix, X and/or y may be copied.</p>
<p>If X is a dense array, then the other methods will not support sparse
matrices as input.</p>
</dd></dl>

<dl class="method">
<dt id="kernelmethods.KernelMachine.get_params">
<code class="sig-name descname">get_params</code><span class="sig-paren">(</span><em class="sig-param">deep=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/kernelmethods/algorithms.html#KernelMachine.get_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kernelmethods.KernelMachine.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>returns all the relevant parameters for this estimator!</p>
</dd></dl>

<dl class="method">
<dt id="kernelmethods.KernelMachine.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param">X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/kernelmethods/algorithms.html#KernelMachine.predict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kernelmethods.KernelMachine.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Make predictions on the new samplets in X.</p>
<p>For an one-class model, +1 or -1 is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – For kernel=”precomputed”, the expected shape of X is
[n_samples_test, n_samples_train]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y_pred</strong> – Class labels for samples in X.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape (n_samples,)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="kernelmethods.KernelMachine.set_learner_params">
<code class="sig-name descname">set_learner_params</code><span class="sig-paren">(</span><em class="sig-param">**learner_params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/kernelmethods/algorithms.html#KernelMachine.set_learner_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kernelmethods.KernelMachine.set_learner_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Separate method to set underlying estimator parameters</p>
</dd></dl>

<dl class="method">
<dt id="kernelmethods.KernelMachine.set_params">
<code class="sig-name descname">set_params</code><span class="sig-paren">(</span><em class="sig-param">**parameters</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/kernelmethods/algorithms.html#KernelMachine.set_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kernelmethods.KernelMachine.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Param setter</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="optimalkernelsvr-api">
<h2>OptimalKernelSVR (API)<a class="headerlink" href="#optimalkernelsvr-api" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="kernelmethods.OptimalKernelSVR">
<em class="property">class </em><code class="sig-prename descclassname">kernelmethods.</code><code class="sig-name descname">OptimalKernelSVR</code><span class="sig-paren">(</span><em class="sig-param">k_bucket</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/kernelmethods/algorithms.html#OptimalKernelSVR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kernelmethods.OptimalKernelSVR" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.svm.classes.SVR</span></code></p>
<p>An estimator to learn the optimal kernel for a given sample and
build a support vector regressor based on this custom kernel.</p>
<p>This class is wrapped around the sklearn SVR estimator to function as its
drop-in replacement, whose implementation is in turn based on LIBSVM.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>k_bucket</strong> (<a class="reference internal" href="km_collections.html#kernelmethods.KernelBucket" title="kernelmethods.KernelBucket"><em>KernelBucket</em></a><em> or </em><em>str</em>) – An instance of KernelBucket that contains all the kernels to be compared,
or a string identifying the sampling_strategy which populates a KernelBucket.</p>
</dd>
</dl>
<dl class="attribute">
<dt id="kernelmethods.OptimalKernelSVR.support_">
<code class="sig-name descname">support_</code><a class="headerlink" href="#kernelmethods.OptimalKernelSVR.support_" title="Permalink to this definition">¶</a></dt>
<dd><p>Indices of support vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array-like, shape = [n_SV]</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="kernelmethods.OptimalKernelSVR.support_vectors_">
<code class="sig-name descname">support_vectors_</code><a class="headerlink" href="#kernelmethods.OptimalKernelSVR.support_vectors_" title="Permalink to this definition">¶</a></dt>
<dd><p>Support vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array-like, shape = [nSV, n_features]</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="kernelmethods.OptimalKernelSVR.dual_coef_">
<code class="sig-name descname">dual_coef_</code><a class="headerlink" href="#kernelmethods.OptimalKernelSVR.dual_coef_" title="Permalink to this definition">¶</a></dt>
<dd><p>Coefficients of the support vector in the decision function.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array, shape = [1, n_SV]</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="kernelmethods.OptimalKernelSVR.coef_">
<code class="sig-name descname">coef_</code><a class="headerlink" href="#kernelmethods.OptimalKernelSVR.coef_" title="Permalink to this definition">¶</a></dt>
<dd><p>Weights assigned to the features (coefficients in the primal
problem). This is only available in the case of a linear kernel.</p>
<p><cite>coef_</cite> is readonly property derived from <cite>dual_coef_</cite> and
<cite>support_vectors_</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array, shape = [1, n_features]</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="kernelmethods.OptimalKernelSVR.intercept_">
<code class="sig-name descname">intercept_</code><a class="headerlink" href="#kernelmethods.OptimalKernelSVR.intercept_" title="Permalink to this definition">¶</a></dt>
<dd><p>Constants in decision function.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array, shape = [1]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">coef_</code></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kernelmethods.OptimalKernelSVR.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">y</em>, <em class="sig-param">sample_weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/kernelmethods/algorithms.html#OptimalKernelSVR.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kernelmethods.OptimalKernelSVR.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the optimal kernel, and fit a SVM based on the custom kernel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Training vectors, where n_samples is the number of samples
and n_features is the number of features.
For kernel=”precomputed”, the expected shape of X is
(n_samples, n_samples).</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>,</em><em>)</em>) – Target values (class labels in classification, real numbers in
regression)</p></li>
<li><p><strong>sample_weight</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>,</em><em>)</em>) – Per-sample weights. Rescale C per sample. Higher weights
force the classifier to put more emphasis on these points.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If X and y are not C-ordered and contiguous arrays of np.float64 and
X is not a scipy.sparse.csr_matrix, X and/or y may be copied.</p>
<p>If X is a dense array, then the other methods will not support sparse
matrices as input.</p>
</dd></dl>

<dl class="method">
<dt id="kernelmethods.OptimalKernelSVR.get_params">
<code class="sig-name descname">get_params</code><span class="sig-paren">(</span><em class="sig-param">deep=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/kernelmethods/algorithms.html#OptimalKernelSVR.get_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kernelmethods.OptimalKernelSVR.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>returns all the relevant parameters for this estimator!</p>
</dd></dl>

<dl class="method">
<dt id="kernelmethods.OptimalKernelSVR.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param">X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/kernelmethods/algorithms.html#OptimalKernelSVR.predict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kernelmethods.OptimalKernelSVR.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform classification on samples in X.</p>
<p>For an one-class model, +1 or -1 is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – For kernel=”precomputed”, the expected shape of X is
[n_samples_test, n_samples_train]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y_pred</strong> – Class labels for samples in X.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape (n_samples,)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="kernelmethods.OptimalKernelSVR.score">
<code class="sig-name descname">score</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">y</em>, <em class="sig-param">sample_weight=None</em><span class="sig-paren">)</span><a class="headerlink" href="#kernelmethods.OptimalKernelSVR.score" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the coefficient of determination R^2 of the prediction.</p>
<p>The coefficient R^2 is defined as (1 - u/v), where u is the residual
sum of squares ((y_true - y_pred) ** 2).sum() and v is the total
sum of squares ((y_true - y_true.mean()) ** 2).sum().
The best possible score is 1.0 and it can be negative (because the
model can be arbitrarily worse). A constant model that always
predicts the expected value of y, disregarding the input features,
would get a R^2 score of 0.0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Test samples. For some estimators this may be a
precomputed kernel matrix instead, shape = (n_samples,
n_samples_fitted], where n_samples_fitted is the number of
samples used in the fitting for the estimator.</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> (</em><em>n_samples</em><em>) or </em><em>(</em><em>n_samples</em><em>, </em><em>n_outputs</em><em>)</em>) – True values for X.</p></li>
<li><p><strong>sample_weight</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>]</em><em>, </em><em>optional</em>) – Sample weights.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>score</strong> – R^2 of self.predict(X) wrt. y.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The R2 score used when calling <code class="docutils literal notranslate"><span class="pre">score</span></code> on a regressor will use
<code class="docutils literal notranslate"><span class="pre">multioutput='uniform_average'</span></code> from version 0.23 to keep consistent
with <cite>metrics.r2_score</cite>. This will influence the <code class="docutils literal notranslate"><span class="pre">score</span></code> method of
all the multioutput regressors (except for
<cite>multioutput.MultiOutputRegressor</cite>). To specify the default value
manually and avoid the warning, please either call <cite>metrics.r2_score</cite>
directly or make a custom scorer with <cite>metrics.make_scorer</cite> (the
built-in scorer <code class="docutils literal notranslate"><span class="pre">'r2'</span></code> uses <code class="docutils literal notranslate"><span class="pre">multioutput='uniform_average'</span></code>).</p>
</dd></dl>

<dl class="method">
<dt id="kernelmethods.OptimalKernelSVR.set_params">
<code class="sig-name descname">set_params</code><span class="sig-paren">(</span><em class="sig-param">**parameters</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/kernelmethods/algorithms.html#OptimalKernelSVR.set_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kernelmethods.OptimalKernelSVR.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Param setter</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Drop-in Estimator classes</a><ul>
<li><a class="reference internal" href="#kernel-machine-api">Kernel Machine (API)</a></li>
<li><a class="reference internal" href="#optimalkernelsvr-api">OptimalKernelSVR (API)</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="km_collections.html"
                        title="previous chapter">Collections of kernel matrices</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="operations.html"
                        title="next chapter">Kernel Operations</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/kernel_machine.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Pradeep Reddy Raamana.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.
    </div>
  </body>
</html>